/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage, Align> {
        storage: Storage,
        align: [Align; 0],
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage, align: [] }
        }
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        impl Default for allocator {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits___pointer<_Alloc> = _Alloc;
        pub type allocator_traits_pointer<_Alloc> = root::std::allocator_traits___pointer<_Alloc>;
        pub type allocator_traits___const_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_pointer<_Alloc> =
            root::std::allocator_traits___const_pointer<_Alloc>;
        pub type allocator_traits___void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_void_pointer<_Alloc> =
            root::std::allocator_traits___void_pointer<_Alloc>;
        pub type allocator_traits___const_void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_void_pointer<_Alloc> =
            root::std::allocator_traits___const_void_pointer<_Alloc>;
        pub type allocator_traits___difference_type<_Alloc> = _Alloc;
        pub type allocator_traits_difference_type<_Alloc> =
            root::std::allocator_traits___difference_type<_Alloc>;
        pub type allocator_traits___size_type<_Alloc> = _Alloc;
        pub type allocator_traits_size_type<_Alloc> =
            root::std::allocator_traits___size_type<_Alloc>;
        pub type allocator_traits___propagate_on_container_copy_assignment<_Alloc> = _Alloc;
        pub type allocator_traits_propagate_on_container_copy_assignment<_Alloc> =
            root::std::allocator_traits___propagate_on_container_copy_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_move_assignment<_Alloc> = _Alloc;
        pub type allocator_traits_propagate_on_container_move_assignment<_Alloc> =
            root::std::allocator_traits___propagate_on_container_move_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_swap<_Alloc> = _Alloc;
        pub type allocator_traits_propagate_on_container_swap<_Alloc> =
            root::std::allocator_traits___propagate_on_container_swap<_Alloc>;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct allocator_traits___allocate_helper {
            pub _address: u8,
        }
        pub type allocator_traits___allocate_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_allocate = root::std::allocator_traits___allocate_helper;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct allocator_traits___destroy_helper {
            pub _address: u8,
        }
        pub type allocator_traits___destroy_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_destroy = root::std::allocator_traits___destroy_helper;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct allocator_traits___maxsize_helper {
            pub _address: u8,
        }
        pub type allocator_traits___maxsize_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_max_size = root::std::allocator_traits___maxsize_helper;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct allocator_traits___select_helper {
            pub _address: u8,
        }
        pub type allocator_traits___select_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_soccc = root::std::allocator_traits___select_helper;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        impl Default for _Vector_base__Vector_impl {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        impl Default for _Vector_base {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Alloc_value_type = [u8; 0usize];
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        impl Default for vector {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct __fun {
            pub _address: u8,
        }
        pub type __fun_result_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug)]
        pub struct valarray<_Tp> {
            pub _M_size: usize,
            pub _M_data: *mut _Tp,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Tp>>,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct valarray__UnaryOp {
            pub _address: u8,
        }
        pub type valarray__UnaryOp___rt = root::std::__fun;
        pub type valarray__UnaryOp__Rt<_Clos> = root::std::_Expr<_Clos>;
        pub type valarray_value_type<_Tp> = _Tp;
        impl<_Tp> Default for valarray<_Tp> {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Expr<_Clos> {
            pub _M_closure: _Clos,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Clos>>,
        }
        pub type _Expr_value_type<_Tp> = _Tp;
        impl<_Clos> Default for _Expr<_Clos> {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        impl<_Iterator> Default for __normal_iterator<_Iterator> {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
    }
    pub mod matrix_hal {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct CircularQueue<T> {
            pub fifo_size_: cty::c_int,
            pub pointer_: cty::c_int,
            pub fifo_: *mut T,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
        }
        impl<T> Default for CircularQueue<T> {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct LedValue {
            pub red: u32,
            pub green: u32,
            pub blue: u32,
            pub white: u32,
        }
        pub const kMatrixCreatorNLeds: cty::c_int = 18;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EverloopImage {
            pub leds: root::std::vector,
        }
        impl Default for EverloopImage {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        pub const kFPGAClock: u32 = 50000000;
        #[repr(C)]
        #[repr(align(2))]
        #[derive(Debug, Default, Copy, Clone)]
        pub struct hardware_address {
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize], u16>,
        }
        impl hardware_address {
            #[inline]
            pub fn readnwrite(&self) -> u8 {
                unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_readnwrite(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn reg(&self) -> u16 {
                unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
            }
            #[inline]
            pub fn set_reg(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 15u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                readnwrite: u8,
                reg: u16,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let readnwrite: u8 = unsafe { ::core::mem::transmute(readnwrite) };
                    readnwrite as u64
                });
                __bindgen_bitfield_unit.set(1usize, 15u8, {
                    let reg: u16 = unsafe { ::core::mem::transmute(reg) };
                    reg as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WishboneBus {
            pub spi_: root::spi_device_handle_t,
            pub fpga_frequency_: u32,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal11WishboneBus4InitEv"]
            pub fn WishboneBus_Init(this: *mut root::matrix_hal::WishboneBus) -> root::esp_err_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal11WishboneBus10RegWrite16Ett"]
            pub fn WishboneBus_RegWrite16(
                this: *mut root::matrix_hal::WishboneBus,
                add: u16,
                data: u16,
            ) -> root::esp_err_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal11WishboneBus9RegRead16EtPt"]
            pub fn WishboneBus_RegRead16(
                this: *mut root::matrix_hal::WishboneBus,
                add: u16,
                data: *mut u16,
            ) -> root::esp_err_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal11WishboneBus7SpiReadEtPhi"]
            pub fn WishboneBus_SpiRead(
                this: *mut root::matrix_hal::WishboneBus,
                add: u16,
                data: *mut u8,
                length: cty::c_int,
            ) -> root::esp_err_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal11WishboneBus8SpiWriteEtPKhi"]
            pub fn WishboneBus_SpiWrite(
                this: *mut root::matrix_hal::WishboneBus,
                add: u16,
                data: *const u8,
                length: cty::c_int,
            ) -> root::esp_err_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal11WishboneBus16GetFPGAFrequencyEv"]
            pub fn WishboneBus_GetFPGAFrequency(
                this: *mut root::matrix_hal::WishboneBus,
            ) -> root::esp_err_t;
        }
        impl Default for WishboneBus {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        impl WishboneBus {
            #[inline]
            pub unsafe fn Init(&mut self) -> root::esp_err_t {
                WishboneBus_Init(self)
            }
            #[inline]
            pub unsafe fn RegWrite16(&mut self, add: u16, data: u16) -> root::esp_err_t {
                WishboneBus_RegWrite16(self, add, data)
            }
            #[inline]
            pub unsafe fn RegRead16(&mut self, add: u16, data: *mut u16) -> root::esp_err_t {
                WishboneBus_RegRead16(self, add, data)
            }
            #[inline]
            pub unsafe fn SpiRead(
                &mut self,
                add: u16,
                data: *mut u8,
                length: cty::c_int,
            ) -> root::esp_err_t {
                WishboneBus_SpiRead(self, add, data, length)
            }
            #[inline]
            pub unsafe fn SpiWrite(
                &mut self,
                add: u16,
                data: *const u8,
                length: cty::c_int,
            ) -> root::esp_err_t {
                WishboneBus_SpiWrite(self, add, data, length)
            }
            #[inline]
            pub unsafe fn GetFPGAFrequency(&mut self) -> root::esp_err_t {
                WishboneBus_GetFPGAFrequency(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MatrixDriver {
            pub wishbone_: *mut root::matrix_hal::WishboneBus,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal12MatrixDriver5SetupEPNS_11WishboneBusE"]
            pub fn MatrixDriver_Setup(
                this: *mut root::matrix_hal::MatrixDriver,
                wishbone: *mut root::matrix_hal::WishboneBus,
            );
        }
        impl Default for MatrixDriver {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        impl MatrixDriver {
            #[inline]
            pub unsafe fn Setup(&mut self, wishbone: *mut root::matrix_hal::WishboneBus) {
                MatrixDriver_Setup(self, wishbone)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Everloop {
            pub _base: root::matrix_hal::MatrixDriver,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal8Everloop5WriteEPKNS_13EverloopImageE"]
            pub fn Everloop_Write(
                this: *mut root::matrix_hal::Everloop,
                led_image: *const root::matrix_hal::EverloopImage,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal8EverloopC1Ev"]
            pub fn Everloop_Everloop(this: *mut root::matrix_hal::Everloop);
        }
        impl Default for Everloop {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        impl Everloop {
            #[inline]
            pub unsafe fn Write(
                &mut self,
                led_image: *const root::matrix_hal::EverloopImage,
            ) -> bool {
                Everloop_Write(self, led_image)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                Everloop_Everloop(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_halL17micarray_locationE"]
            pub static mut micarray_location: [[f32; 2usize]; 8usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_halL24MIC_sampling_frequenciesE"]
            pub static mut MIC_sampling_frequencies: [[u32; 3usize]; 10usize];
        }
        pub const kMicarrayBufferSize: u16 = 4096;
        pub const kMicrophoneArrayIRQ: u16 = 5;
        pub const kMicrophoneChannels: u16 = 8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct MicrophoneArray {
            pub _base: root::matrix_hal::MatrixDriver,
            pub beamformed_: root::std::valarray<i16>,
            pub raw_data_: root::std::valarray<i16>,
            pub delayed_data_: root::std::valarray<i16>,
            pub gain_: i16,
            pub sampling_frequency_: u16,
            pub fifos_: root::std::valarray<root::matrix_hal::CircularQueue<i16>>,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray5SetupEPNS_11WishboneBusE"]
            pub fn MicrophoneArray_Setup(
                this: *mut root::matrix_hal::MicrophoneArray,
                wishbone: *mut root::matrix_hal::WishboneBus,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray4ReadEv"]
            pub fn MicrophoneArray_Read(this: *mut root::matrix_hal::MicrophoneArray) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray15SetSamplingRateEj"]
            pub fn MicrophoneArray_SetSamplingRate(
                this: *mut root::matrix_hal::MicrophoneArray,
                sampling_frequency: u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray15GetSamplingRateEv"]
            pub fn MicrophoneArray_GetSamplingRate(
                this: *mut root::matrix_hal::MicrophoneArray,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray7GetGainEv"]
            pub fn MicrophoneArray_GetGain(this: *mut root::matrix_hal::MicrophoneArray) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray7SetGainEt"]
            pub fn MicrophoneArray_SetGain(
                this: *mut root::matrix_hal::MicrophoneArray,
                gain: u16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray14ReadConfValuesEv"]
            pub fn MicrophoneArray_ReadConfValues(this: *mut root::matrix_hal::MicrophoneArray);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArray15CalculateDelaysEffff"]
            pub fn MicrophoneArray_CalculateDelays(
                this: *mut root::matrix_hal::MicrophoneArray,
                azimutal_angle: f32,
                polar_angle: f32,
                radial_distance_mm: f32,
                sound_speed_mmseg: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArrayC1Ev"]
            pub fn MicrophoneArray_MicrophoneArray(this: *mut root::matrix_hal::MicrophoneArray);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal15MicrophoneArrayD1Ev"]
            pub fn MicrophoneArray_MicrophoneArray_destructor(
                this: *mut root::matrix_hal::MicrophoneArray,
            );
        }
        impl Default for MicrophoneArray {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        impl MicrophoneArray {
            #[inline]
            pub unsafe fn Setup(&mut self, wishbone: *mut root::matrix_hal::WishboneBus) {
                MicrophoneArray_Setup(self, wishbone)
            }
            #[inline]
            pub unsafe fn Read(&mut self) -> bool {
                MicrophoneArray_Read(self)
            }
            #[inline]
            pub unsafe fn SetSamplingRate(&mut self, sampling_frequency: u32) -> bool {
                MicrophoneArray_SetSamplingRate(self, sampling_frequency)
            }
            #[inline]
            pub unsafe fn GetSamplingRate(&mut self) -> bool {
                MicrophoneArray_GetSamplingRate(self)
            }
            #[inline]
            pub unsafe fn GetGain(&mut self) -> bool {
                MicrophoneArray_GetGain(self)
            }
            #[inline]
            pub unsafe fn SetGain(&mut self, gain: u16) -> bool {
                MicrophoneArray_SetGain(self, gain)
            }
            #[inline]
            pub unsafe fn ReadConfValues(&mut self) {
                MicrophoneArray_ReadConfValues(self)
            }
            #[inline]
            pub unsafe fn CalculateDelays(
                &mut self,
                azimutal_angle: f32,
                polar_angle: f32,
                radial_distance_mm: f32,
                sound_speed_mmseg: f32,
            ) {
                MicrophoneArray_CalculateDelays(
                    self,
                    azimutal_angle,
                    polar_angle,
                    radial_distance_mm,
                    sound_speed_mmseg,
                )
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                MicrophoneArray_MicrophoneArray(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                MicrophoneArray_MicrophoneArray_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIRCoeff {
            pub rate_: u32,
            pub coeff_: root::std::valarray<i16>,
        }
        impl Default for FIRCoeff {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        pub const kNumberFIRTaps: u16 = 128;
        #[repr(C)]
        #[derive(Debug)]
        pub struct MicrophoneCore {
            pub _base: root::matrix_hal::MatrixDriver,
            pub mics_: *mut root::matrix_hal::MicrophoneArray,
            pub fir_coeff_: root::std::valarray<i16>,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal14MicrophoneCore5SetupEPNS_11WishboneBusE"]
            pub fn MicrophoneCore_Setup(
                this: *mut root::matrix_hal::MicrophoneCore,
                wishbone: *mut root::matrix_hal::WishboneBus,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal14MicrophoneCore11SetFIRCoeffEv"]
            pub fn MicrophoneCore_SetFIRCoeff(this: *mut root::matrix_hal::MicrophoneCore) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal14MicrophoneCore17SetCustomFIRCoeffESt8valarrayIsE"]
            pub fn MicrophoneCore_SetCustomFIRCoeff(
                this: *mut root::matrix_hal::MicrophoneCore,
                custom_fir: root::std::valarray<i16>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal14MicrophoneCore14SelectFIRCoeffEPNS_8FIRCoeffE"]
            pub fn MicrophoneCore_SelectFIRCoeff(
                this: *mut root::matrix_hal::MicrophoneCore,
                FIR_coeff: *mut root::matrix_hal::FIRCoeff,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal14MicrophoneCore11SetFIRCoeffESt8valarrayIsE"]
            pub fn MicrophoneCore_SetFIRCoeff1(
                this: *mut root::matrix_hal::MicrophoneCore,
                custom_fir: root::std::valarray<i16>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal14MicrophoneCoreC1ERNS_15MicrophoneArrayE"]
            pub fn MicrophoneCore_MicrophoneCore(
                this: *mut root::matrix_hal::MicrophoneCore,
                mics: *mut root::matrix_hal::MicrophoneArray,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal14MicrophoneCoreD1Ev"]
            pub fn MicrophoneCore_MicrophoneCore_destructor(
                this: *mut root::matrix_hal::MicrophoneCore,
            );
        }
        impl Default for MicrophoneCore {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        impl MicrophoneCore {
            #[inline]
            pub unsafe fn Setup(&mut self, wishbone: *mut root::matrix_hal::WishboneBus) {
                MicrophoneCore_Setup(self, wishbone)
            }
            #[inline]
            pub unsafe fn SetFIRCoeff(&mut self) -> bool {
                MicrophoneCore_SetFIRCoeff(self)
            }
            #[inline]
            pub unsafe fn SetCustomFIRCoeff(
                &mut self,
                custom_fir: root::std::valarray<i16>,
            ) -> bool {
                MicrophoneCore_SetCustomFIRCoeff(self, custom_fir)
            }
            #[inline]
            pub unsafe fn SelectFIRCoeff(
                &mut self,
                FIR_coeff: *mut root::matrix_hal::FIRCoeff,
            ) -> bool {
                MicrophoneCore_SelectFIRCoeff(self, FIR_coeff)
            }
            #[inline]
            pub unsafe fn SetFIRCoeff1(&mut self, custom_fir: root::std::valarray<i16>) -> bool {
                MicrophoneCore_SetFIRCoeff1(self, custom_fir)
            }
            #[inline]
            pub unsafe fn new(mics: *mut root::matrix_hal::MicrophoneArray) -> Self {
                let mut __bindgen_tmp = ::core::mem::uninitialized();
                MicrophoneCore_MicrophoneCore(&mut __bindgen_tmp, mics);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                MicrophoneCore_MicrophoneCore_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10matrix_hal11FIR_defaultE"]
            pub static mut FIR_default: [root::matrix_hal::FIRCoeff; 10usize];
        }
        pub const kConfBaseAddress: u32 = 0;
        pub const kMicrophoneArrayBaseAddress: u32 = 8192;
        pub const kEverloopBaseAddress: u32 = 12288;
        pub const kDACBaseAddress: u32 = 24576;
    }
    pub type __uint8_t = cty::c_uchar;
    pub type __int16_t = cty::c_short;
    pub type __uint16_t = cty::c_ushort;
    pub type __int32_t = cty::c_int;
    pub type __uint32_t = cty::c_uint;
    pub type esp_err_t = i32;
    #[doc = "< return successful in ets"]
    pub const ETS_STATUS_ETS_OK: root::ETS_STATUS = 0;
    #[doc = "< return failed in ets"]
    pub const ETS_STATUS_ETS_FAILED: root::ETS_STATUS = 1;
    #[doc = " @addtogroup ets_apis"]
    #[doc = " @{"]
    pub type ETS_STATUS = u32;
    pub type ETSSignal = u32;
    pub type ETSParam = u32;
    pub type ETSEvent = root::ETSEventTag;
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone)]
    pub struct ETSEventTag {
        #[doc = "< Event signal, in same task, different Event with different signal"]
        pub sig: root::ETSSignal,
        #[doc = "< Event parameter, sometimes without usage, then will be set as 0"]
        pub par: root::ETSParam,
    }
    pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut root::ETSEvent)>;
    pub type ets_idle_cb_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
    extern "C" {
        #[doc = " @brief  Start the Espressif Task Scheduler, which is an infinit loop. Please do not add code after it."]
        #[doc = ""]
        #[doc = " @param  none"]
        #[doc = ""]
        #[doc = " @return none"]
        pub fn ets_run();
    }
    extern "C" {
        #[doc = " @brief  Set the Idle callback, when Tasks are processed, will call the callback before CPU goto sleep."]
        #[doc = ""]
        #[doc = " @param  ets_idle_cb_t func : The callback function."]
        #[doc = ""]
        #[doc = " @param  void *arg : Argument of the callback."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_set_idle_cb(func: root::ets_idle_cb_t, arg: *mut cty::c_void);
    }
    extern "C" {
        #[doc = " @brief  Init a task with processer, priority, queue to receive Event, queue length."]
        #[doc = ""]
        #[doc = " @param  ETSTask task : The task processer."]
        #[doc = ""]
        #[doc = " @param  uint8_t prio : Task priority, 0-31, bigger num with high priority, one priority with one task."]
        #[doc = ""]
        #[doc = " @param  ETSEvent *queue : Queue belongs to the task, task always receives Events, Queue is circular used."]
        #[doc = ""]
        #[doc = " @param  uint8_t qlen : Queue length."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_task(task: root::ETSTask, prio: u8, queue: *mut root::ETSEvent, qlen: u8);
    }
    extern "C" {
        #[doc = " @brief  Post an event to an Task."]
        #[doc = ""]
        #[doc = " @param  uint8_t prio : Priority of the Task."]
        #[doc = ""]
        #[doc = " @param  ETSSignal sig : Event signal."]
        #[doc = ""]
        #[doc = " @param  ETSParam  par : Event parameter"]
        #[doc = ""]
        #[doc = " @return ETS_OK     : post successful"]
        #[doc = " @return ETS_FAILED : post failed"]
        pub fn ets_post(prio: u8, sig: root::ETSSignal, par: root::ETSParam) -> root::ETS_STATUS;
    }
    extern "C" {
        #[doc = " @brief  Set Pro cpu Entry code, code can be called in PRO CPU when booting is not completed."]
        #[doc = "         When Pro CPU booting is completed, Pro CPU will call the Entry code if not NULL."]
        #[doc = ""]
        #[doc = " @param  uint32_t start : the PRO Entry code address value in uint32_t"]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_set_user_start(start: u32);
    }
    extern "C" {
        #[doc = " @brief  Set Pro cpu Startup code, code can be called when booting is not completed, or in Entry code."]
        #[doc = "         When Entry code completed, CPU will call the Startup code if not NULL, else call ets_run."]
        #[doc = ""]
        #[doc = " @param  uint32_t callback : the Startup code address value in uint32_t"]
        #[doc = ""]
        #[doc = " @return None     : post successful"]
        pub fn ets_set_startup_callback(callback: u32);
    }
    extern "C" {
        #[doc = " @brief  Set App cpu Entry code, code can be called in PRO CPU."]
        #[doc = "         When APP booting is completed, APP CPU will call the Entry code if not NULL."]
        #[doc = ""]
        #[doc = " @param  uint32_t start : the APP Entry code address value in uint32_t, stored in register APPCPU_CTRL_REG_D."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_set_appcpu_boot_addr(start: u32);
    }
    extern "C" {
        #[doc = " @brief  unpack the image in flash to iram and dram, no using cache."]
        #[doc = ""]
        #[doc = " @param  uint32_t pos : Flash physical address."]
        #[doc = ""]
        #[doc = " @param  uint32_t *entry_addr: the pointer of an variable that can store Entry code address."]
        #[doc = ""]
        #[doc = " @param  bool jump : Jump into the code in the function or not."]
        #[doc = ""]
        #[doc = " @param  bool config : Config the flash when unpacking the image, config should be done only once."]
        #[doc = ""]
        #[doc = " @return ETS_OK     : unpack successful"]
        #[doc = " @return ETS_FAILED : unpack failed"]
        pub fn ets_unpack_flash_code_legacy(
            pos: u32,
            entry_addr: *mut u32,
            jump: bool,
            config: bool,
        ) -> root::ETS_STATUS;
    }
    extern "C" {
        #[doc = " @brief  unpack the image in flash to iram and dram, using cache, maybe decrypting."]
        #[doc = ""]
        #[doc = " @param  uint32_t pos : Flash physical address."]
        #[doc = ""]
        #[doc = " @param  uint32_t *entry_addr: the pointer of an variable that can store Entry code address."]
        #[doc = ""]
        #[doc = " @param  bool jump : Jump into the code in the function or not."]
        #[doc = ""]
        #[doc = " @param  bool sb_need_check : Do security boot check or not."]
        #[doc = ""]
        #[doc = " @param  bool config : Config the flash when unpacking the image, config should be done only once."]
        #[doc = ""]
        #[doc = " @return ETS_OK     : unpack successful"]
        #[doc = " @return ETS_FAILED : unpack failed"]
        pub fn ets_unpack_flash_code(
            pos: u32,
            entry_addr: *mut u32,
            jump: bool,
            sb_need_check: bool,
            config: bool,
        ) -> root::ETS_STATUS;
    }
    extern "C" {
        #[doc = " @brief  Printf the strings to uart or other devices, similar with printf, simple than printf."]
        #[doc = "         Can not print float point data format, or longlong data format."]
        #[doc = "         So we maybe only use this in ROM."]
        #[doc = ""]
        #[doc = " @param  const char *fmt : See printf."]
        #[doc = ""]
        #[doc = " @param  ... : See printf."]
        #[doc = ""]
        #[doc = " @return int : the length printed to the output device."]
        pub fn ets_printf(fmt: *const cty::c_char, ...) -> cty::c_int;
    }
    extern "C" {
        #[doc = " @brief  Output a char to uart, which uart to output(which is in uart module in ROM) is not in scope of the function."]
        #[doc = "         Can not print float point data format, or longlong data format"]
        #[doc = ""]
        #[doc = " @param  char c : char to output."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_write_char_uart(c: cty::c_char);
    }
    extern "C" {
        #[doc = " @brief  Ets_printf have two output functions\u{ff1a} putc1 and putc2, both of which will be called if need ouput."]
        #[doc = "         To install putc1, which is defaulted installed as ets_write_char_uart in none silent boot mode, as NULL in silent mode."]
        #[doc = ""]
        #[doc = " @param  void (*)(char) p: Output function to install."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_install_putc1(p: ::core::option::Option<unsafe extern "C" fn(c: cty::c_char)>);
    }
    extern "C" {
        #[doc = " @brief  Ets_printf have two output functions\u{ff1a} putc1 and putc2, both of which will be called if need ouput."]
        #[doc = "         To install putc2, which is defaulted installed as NULL."]
        #[doc = ""]
        #[doc = " @param  void (*)(char) p: Output function to install."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_install_putc2(p: ::core::option::Option<unsafe extern "C" fn(c: cty::c_char)>);
    }
    extern "C" {
        #[doc = " @brief  Install putc1 as ets_write_char_uart."]
        #[doc = "         In silent boot mode(to void interfere the UART attached MCU), we can call this function, after booting ok."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_install_uart_printf();
    }
    #[doc = " @addtogroup ets_timer_apis"]
    #[doc = " @{"]
    pub type ETSTimerFunc =
        ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut cty::c_void)>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _ETSTIMER_ {
        #[doc = "< timer linker"]
        pub timer_next: *mut root::_ETSTIMER_,
        #[doc = "< abstruct time when timer expire"]
        pub timer_expire: u32,
        #[doc = "< timer period, 0 means timer is not periodic repeated"]
        pub timer_period: u32,
        #[doc = "< timer handler"]
        pub timer_func: root::ETSTimerFunc,
        #[doc = "< timer handler argument"]
        pub timer_arg: *mut cty::c_void,
    }
    impl Default for _ETSTIMER_ {
        fn default() -> Self {
            unsafe { ::core::mem::zeroed() }
        }
    }
    pub type ETSTimer = root::_ETSTIMER_;
    extern "C" {
        #[doc = " @brief  Init ets timer, this timer range is 640 us to 429496 ms"]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_timer_init();
    }
    extern "C" {
        #[doc = " @brief  In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_timer_deinit();
    }
    extern "C" {
        #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
        #[doc = ""]
        #[doc = " @param  uint32_t tmout : Timer value in ms, range is 1 to 429496."]
        #[doc = ""]
        #[doc = " @param  bool repeat : Timer is periodic repeated."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_timer_arm(timer: *mut root::ETSTimer, tmout: u32, repeat: bool);
    }
    extern "C" {
        #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
        #[doc = ""]
        #[doc = " @param  uint32_t tmout : Timer value in us, range is 1 to 429496729."]
        #[doc = ""]
        #[doc = " @param  bool repeat : Timer is periodic repeated."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_timer_arm_us(ptimer: *mut root::ETSTimer, us: u32, repeat: bool);
    }
    extern "C" {
        #[doc = " @brief  Disarm an ets timer."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_timer_disarm(timer: *mut root::ETSTimer);
    }
    extern "C" {
        #[doc = " @brief  Set timer callback and argument."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
        #[doc = ""]
        #[doc = " @param  ETSTimerFunc *pfunction : Timer callback."]
        #[doc = ""]
        #[doc = " @param  void *parg : Timer callback argument."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_timer_setfn(
            ptimer: *mut root::ETSTimer,
            pfunction: root::ETSTimerFunc,
            parg: *mut cty::c_void,
        );
    }
    extern "C" {
        #[doc = " @brief  Unset timer callback and argument to NULL."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_timer_done(ptimer: *mut root::ETSTimer);
    }
    extern "C" {
        #[doc = " @brief  CPU do while loop for some time."]
        #[doc = "         In FreeRTOS task, please call FreeRTOS apis."]
        #[doc = ""]
        #[doc = " @param  uint32_t us : Delay time in us."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_delay_us(us: u32);
    }
    extern "C" {
        #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate."]
        #[doc = "         Call this function when CPU frequency is changed."]
        #[doc = ""]
        #[doc = " @param  uint32_t ticks_per_us : CPU ticks per us."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_update_cpu_frequency(ticks_per_us: u32);
    }
    extern "C" {
        #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate."]
        #[doc = ""]
        #[doc = " @note This function only sets the tick rate for the current CPU. It is located in ROM,"]
        #[doc = "       so the deep sleep stub can use it even if IRAM is not initialized yet."]
        #[doc = ""]
        #[doc = " @param  uint32_t ticks_per_us : CPU ticks per us."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_update_cpu_frequency_rom(ticks_per_us: u32);
    }
    extern "C" {
        #[doc = " @brief  Get the real CPU ticks per us to the ets."]
        #[doc = "         This function do not return real CPU ticks per us, just the record in ets. It can be used to check with the real CPU frequency."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return uint32_t : CPU ticks per us record in ets."]
        pub fn ets_get_cpu_frequency() -> u32;
    }
    extern "C" {
        #[doc = " @brief  Get xtal_freq/analog_8M*256 value calibrated in rtc module."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return uint32_t : xtal_freq/analog_8M*256."]
        pub fn ets_get_xtal_scale() -> u32;
    }
    extern "C" {
        #[doc = " @brief  Get xtal_freq value, If value not stored in RTC_STORE5, than store."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return uint32_t : if rtc store the value (RTC_STORE5 high 16 bits and low 16 bits with same value), read from rtc register."]
        #[doc = "                         clock = (REG_READ(RTC_STORE5) & 0xffff) << 12;"]
        #[doc = "            else if analog_8M in efuse"]
        #[doc = "                         clock = ets_get_xtal_scale() * 15625 * ets_efuse_get_8M_clock() / 40;"]
        #[doc = "                    else clock = 26M."]
        pub fn ets_get_detected_xtal_freq() -> u32;
    }
    #[doc = " @addtogroup ets_intr_apis"]
    #[doc = " @{"]
    pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
    extern "C" {
        #[doc = " @brief  Attach a interrupt handler to a CPU interrupt number."]
        #[doc = "         This function equals to _xtos_set_interrupt_handler_arg(i, func, arg)."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  int i : CPU interrupt number."]
        #[doc = ""]
        #[doc = " @param  ets_isr_t func : Interrupt handler."]
        #[doc = ""]
        #[doc = " @param  void *arg : argument of the handler."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_isr_attach(i: cty::c_int, func: root::ets_isr_t, arg: *mut cty::c_void);
    }
    extern "C" {
        #[doc = " @brief  Mask the interrupts which show in mask bits."]
        #[doc = "         This function equals to _xtos_ints_off(mask)."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  uint32_t mask : BIT(i) means mask CPU interrupt number i."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_isr_mask(mask: u32);
    }
    extern "C" {
        #[doc = " @brief  Unmask the interrupts which show in mask bits."]
        #[doc = "         This function equals to _xtos_ints_on(mask)."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  uint32_t mask : BIT(i) means mask CPU interrupt number i."]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_isr_unmask(unmask: u32);
    }
    extern "C" {
        #[doc = " @brief  Lock the interrupt to level 2."]
        #[doc = "         This function direct set the CPU registers."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_intr_lock();
    }
    extern "C" {
        #[doc = " @brief  Unlock the interrupt to level 0."]
        #[doc = "         This function direct set the CPU registers."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_intr_unlock();
    }
    extern "C" {
        #[doc = " @brief  Unlock the interrupt to level 0, and CPU will go into power save mode(wait interrupt)."]
        #[doc = "         This function direct set the CPU registers."]
        #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
        #[doc = ""]
        #[doc = " @param  None"]
        #[doc = ""]
        #[doc = " @return None"]
        pub fn ets_waiti0();
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct spi_device_t {
        _unused: [u8; 0],
    }
    pub type spi_device_handle_t = *mut root::spi_device_t;
}
