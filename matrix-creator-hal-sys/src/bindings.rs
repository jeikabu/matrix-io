/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type std_string = std_basic_string<::std::os::raw::c_char>;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
impl Default for std_basic_string__Alloc_hider {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 =
    std_basic_string__bindgen_ty_1::_S_local_capacity;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std_basic_string__bindgen_ty_1 {
    _S_local_capacity = 0,
}
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u32,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
}
impl<_CharT> Default for std_basic_string__bindgen_ty_2<_CharT> {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl<_CharT> Default for std_basic_string<_CharT> {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
impl Default for std_pointer_traits___rebind {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
impl<_Iterator> Default for std_reverse_iterator<_Iterator> {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type std_streamoff = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_StateT>>,
}
impl<_StateT> Default for std_fpos<_StateT> {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type std_streampos = std_fpos<mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
impl Default for std_char_traits {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
impl Default for std_allocator {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
impl Default for std___allocator_traits_base___rebind {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::core::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::core::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
impl Default for std_allocator_traits__Size {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std___mutex_base {
    pub _M_mutex: std___mutex_base___native_type,
}
pub type std___mutex_base___native_type = __gthread_mutex_t;
#[test]
fn bindgen_test_layout_std___mutex_base() {
    assert_eq!(
        ::core::mem::size_of::<std___mutex_base>(),
        24usize,
        concat!("Size of: ", stringify!(std___mutex_base))
    );
    assert_eq!(
        ::core::mem::align_of::<std___mutex_base>(),
        4usize,
        concat!("Alignment of ", stringify!(std___mutex_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<std___mutex_base>()))._M_mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___mutex_base),
            "::",
            stringify!(_M_mutex)
        )
    );
}
impl Default for std___mutex_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct std_mutex {
    pub _base: std___mutex_base,
}
pub type std_mutex_native_handle_type = *mut std___mutex_base___native_type;
#[test]
fn bindgen_test_layout_std_mutex() {
    assert_eq!(
        ::core::mem::size_of::<std_mutex>(),
        24usize,
        concat!("Size of: ", stringify!(std_mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<std_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(std_mutex))
    );
}
impl Default for std_mutex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
impl<_Iterator> Default for __gnu_cxx___normal_iterator<_Iterator> {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug, Default)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = usize;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
impl Default for __gnu_cxx___alloc_traits {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __kind: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_slist_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_mutex_s__bindgen_ty_1>())).__spins as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_mutex_s__bindgen_ty_1>())).__list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 24usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __gthread_mutex_t = pthread_mutex_t;
#[repr(C)]
pub struct matrix_hal_Bus__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
pub struct matrix_hal_Bus {
    pub vtable_: *const matrix_hal_Bus__bindgen_vtable,
    pub device_name_: std_string,
    pub rx_buffer_: [::std::os::raw::c_uchar; 12288usize],
    pub tx_buffer_: [::std::os::raw::c_uchar; 12288usize],
    pub mutex_: std_mutex,
}
#[test]
fn bindgen_test_layout_matrix_hal_Bus() {
    assert_eq!(
        ::core::mem::size_of::<matrix_hal_Bus>(),
        24628usize,
        concat!("Size of: ", stringify!(matrix_hal_Bus))
    );
    assert_eq!(
        ::core::mem::align_of::<matrix_hal_Bus>(),
        4usize,
        concat!("Alignment of ", stringify!(matrix_hal_Bus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<matrix_hal_Bus>())).device_name_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_Bus),
            "::",
            stringify!(device_name_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<matrix_hal_Bus>())).rx_buffer_ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_Bus),
            "::",
            stringify!(rx_buffer_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<matrix_hal_Bus>())).tx_buffer_ as *const _ as usize },
        12316usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_Bus),
            "::",
            stringify!(tx_buffer_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<matrix_hal_Bus>())).mutex_ as *const _ as usize },
        24604usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_Bus),
            "::",
            stringify!(mutex_)
        )
    );
}
impl Default for matrix_hal_Bus {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const matrix_hal_kFPGAClock: u32 = 50000000;
pub const matrix_hal_kMatrixCreatorNLeds: ::std::os::raw::c_int = 35;
pub const matrix_hal_kMatrixVoiceNLeds: ::std::os::raw::c_int = 18;
pub const matrix_hal_kMatrixCreator: ::std::os::raw::c_int = 96683240;
pub const matrix_hal_kMatrixVoice: ::std::os::raw::c_int = 1613937362;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matrix_hal_MatrixIOBus {
    pub fpga_frequency_: u32,
    pub matrix_name_: u32,
    pub matrix_version_: u32,
    pub matrix_leds_: ::std::os::raw::c_int,
    pub bus_driver_: *mut matrix_hal_Bus,
    pub direct_nkernel_: bool,
}
#[test]
fn bindgen_test_layout_matrix_hal_MatrixIOBus() {
    assert_eq!(
        ::core::mem::size_of::<matrix_hal_MatrixIOBus>(),
        24usize,
        concat!("Size of: ", stringify!(matrix_hal_MatrixIOBus))
    );
    assert_eq!(
        ::core::mem::align_of::<matrix_hal_MatrixIOBus>(),
        4usize,
        concat!("Alignment of ", stringify!(matrix_hal_MatrixIOBus))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<matrix_hal_MatrixIOBus>())).fpga_frequency_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_MatrixIOBus),
            "::",
            stringify!(fpga_frequency_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<matrix_hal_MatrixIOBus>())).matrix_name_ as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_MatrixIOBus),
            "::",
            stringify!(matrix_name_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<matrix_hal_MatrixIOBus>())).matrix_version_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_MatrixIOBus),
            "::",
            stringify!(matrix_version_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<matrix_hal_MatrixIOBus>())).matrix_leds_ as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_MatrixIOBus),
            "::",
            stringify!(matrix_leds_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<matrix_hal_MatrixIOBus>())).bus_driver_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_MatrixIOBus),
            "::",
            stringify!(bus_driver_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<matrix_hal_MatrixIOBus>())).direct_nkernel_ as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(matrix_hal_MatrixIOBus),
            "::",
            stringify!(direct_nkernel_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10matrix_hal11MatrixIOBus4InitEv"]
    pub fn matrix_hal_MatrixIOBus_Init(this: *mut matrix_hal_MatrixIOBus) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10matrix_hal11MatrixIOBus5WriteEtPhi"]
    pub fn matrix_hal_MatrixIOBus_Write(
        this: *mut matrix_hal_MatrixIOBus,
        add: u16,
        data: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10matrix_hal11MatrixIOBus4ReadEtPhi"]
    pub fn matrix_hal_MatrixIOBus_Read(
        this: *mut matrix_hal_MatrixIOBus,
        add: u16,
        data: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10matrix_hal11MatrixIOBus5WriteEtt"]
    pub fn matrix_hal_MatrixIOBus_Write1(
        this: *mut matrix_hal_MatrixIOBus,
        add: u16,
        data: u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10matrix_hal11MatrixIOBus4ReadEtPt"]
    pub fn matrix_hal_MatrixIOBus_Read1(
        this: *mut matrix_hal_MatrixIOBus,
        add: u16,
        data: *mut u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10matrix_hal11MatrixIOBusC1Ev"]
    pub fn matrix_hal_MatrixIOBus_MatrixIOBus(this: *mut matrix_hal_MatrixIOBus);
}
impl Default for matrix_hal_MatrixIOBus {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl matrix_hal_MatrixIOBus {
    #[inline]
    pub unsafe fn Init(&mut self) -> bool {
        matrix_hal_MatrixIOBus_Init(self)
    }
    #[inline]
    pub unsafe fn Write(
        &mut self,
        add: u16,
        data: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> bool {
        matrix_hal_MatrixIOBus_Write(self, add, data, length)
    }
    #[inline]
    pub unsafe fn Read(
        &mut self,
        add: u16,
        data: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> bool {
        matrix_hal_MatrixIOBus_Read(self, add, data, length)
    }
    #[inline]
    pub unsafe fn Write1(&mut self, add: u16, data: u16) -> bool {
        matrix_hal_MatrixIOBus_Write1(self, add, data)
    }
    #[inline]
    pub unsafe fn Read1(&mut self, add: u16, data: *mut u16) -> bool {
        matrix_hal_MatrixIOBus_Read1(self, add, data)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        matrix_hal_MatrixIOBus_MatrixIOBus(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
